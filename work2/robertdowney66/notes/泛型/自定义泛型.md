#自定义泛型
##1.自定义泛型类\接口
###1.1格式
class A <T> 0{

}

interface B<T1,T2>
###1.2使用说明
1. 我们在声明完泛型类以后，可以在类的内部（比如：属性，方法，构造器中）使用类的泛型。
2. 我们在创建自定义泛型类的对象时，可以指明泛型参数类型。一旦指明，凡是内部使用类的泛型参数的位置，都具体转化为指定的类的泛型类型。
3. 如果在创建自定义泛型类的对象时，没有指明泛型类型参数类型，那么泛型将被删除，泛型对应的类型按照Object处理，但**不等价**于Object（下一章再讲）。
- **经验：泛型要使用一路都要使用。要不用，一路都不要用。**
4. 泛型中指定中必须使用引用数据类型，不能使用基本数据类型，此时只能用包装类替换
5. 除创建泛型类的对象外，子类继承泛型类时、实现类实现泛型接口时，也可以确定泛型结构中的泛型类型。（SubOrder2）如果我们在给泛型类提供子类时，子类也不确定泛型的类型，则可以继续使用泛型参数。（SubOrder3）我们还可以在现有的父类基础上，新增泛型参数。（SubOrder5）
###1.3注意点
1. 泛型类可能有多个参数，此时将多个参数一起放在尖括号里。比如：<E1,E2,E3>
2. JDK7.0开始，泛型的简化操作，ArrayList<Fruit> flist = new ArrayList<>();
3. 如果泛型结构是一个接口或抽象类，则不可以创建泛型类的对象。
4. 不能使用new E[]。 但是可以E[] elements = (E[])new Object[capacity]; 
- 参考：ArrayList源码中声明：Object[] elementDate，而非泛型参数类型数组。
5. 再类/接口上声明的泛型，在本类或本接口中即代表某种类型，但不可以在静态方法中使用类的泛型。
6. 异常类是不能带泛型的。

##2.自定义泛型方法
###2.1问题：在泛型类的方法中，使用了类的泛型参数。那么此方法是泛型方法吗？
不是
###2.2格式
权限修饰符 <T> 返回值类型 方法名（形参列表）{  //通常在形参列表或者返回值类型的位置会出现泛型参数T

}
###2.3举例
public <E> E method（E e）
###2.4说明
>声明泛型方法时，一定要添加泛型参数<T>
>泛型参数方法调用时，指明其具体的类型
>泛型方法可以根据需要声明为static的
>泛型方法所属的类是否是一个泛型类，都可以。
