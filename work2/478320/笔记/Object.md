# Object

没有成员变量，只有空参构造

在继承时有一个问题，继承类默认访问父类的无参构造，为什么呢，因为在顶层的构造中只有无参的构造方法

三个常见方法

1. public String toString（）返回对象的字符串表现形式，如果对对象使用就会返回对象的地址值，地址值由三部分组成，前面一部分是对象所在的包名加类名加@加对象的地址值，源代码返回包名加类名加@利用哈希值进行十六进制等复杂计算再返回

   直接打印对象和使用toString方法结果是一样的，现在了解一下输出语句，System的out是一个静态变量，初始值是null，不过后面会给他赋值它的类型是PrintStream，System.out可以获取打印的对象，println方法会调用String里的valueof方法把对象传递过去，而valueof会判断当前对象是否为空，如果是空返回字符串null，如果不是空就会调用toString方法，再交给writeln打印并换行，核心逻辑，当我们打印一个对象的时候，底层会调用对象的toString方法，把对象变成字符串，然后打印在控制台上，打印完毕换行处理，所有我们打印一个对象的时候，默认打印的是地址值，这个没有意义，为了让这个有意义看到对象内部的属性值，就需要在子类toString重写，

2. public boolean equals比较两个对象是否相等，直接比较两个对象，会比较两个对象的地址值，这也是没有意义的，要比较两个对象的属性值，我们就需要重写equals方法，默认转换时，会先判断地址值，然后再判断他们的类型，接着把Object类型的o强转为Student类型，然后调用Objects里的equals方法比较这两个对象内部的属性值，有一个点需要注意，在我们比较两个不同类型的对象时，需要注意调用的是谁的equals方法，结果是不一样的，比较的东西都不一样，String类型重写的equals方法会先比较是不是同一个对象，接着用instanceof来判断两个对象是不是同一类型，最后判断他们的属性，只有全部都相等才会输出true

3. protect Object clone对象克隆

   我可以把A对象里面的属性值完全克隆给B对象，比如在游戏信息转移时就可以用对象扩容

   我们不能直接用对象调用克隆方法，因为克隆的修饰符是protect，说明克隆方法只能被本包中的类，和其他包中的子类使用，我们不能把代码写lang包下，我们只能自己重写，返回父类中的clone方法，我们还需要让本类实现一个额外的Cloneable接口，它里面没有额外的方法，这个接口是一个标记性接口，表示，一旦实现了，那么当前类的对象就可被克隆，如果没有实现就带表当前类的对象不可被克隆，最后我们让一个对应的类的对象，等于原来的对象调用的克隆结果就可以了，但是这里有一个问题，我们克隆方法是克隆Object，我们需要用强制转换把原来的对象转换成我们需要的类的类型

   细节，方法在底层会帮我们创建一个对象，并把原来对象的数据拷贝过去1.要重写Object的克隆的方法2.实现Cloneable接口，强制转换

## 浅克隆

   Java中的克隆方式有两种，第一种基本数据类型拷贝数值，引用类型拷贝数组地址，但是这样会有个问题，两个对象就会使用同一个数组，只要有一个对象对数组产生了改变，两个数组引用数据类型的数据都会变，这种克隆方式叫做浅克隆

## 深克隆

   它第一步创建对象是一样的，如果是基本数据类型就会直接拷贝变量的值，如果是引用数据类型以数组为例，就会在外部再创建一个新的对象，然后把原来数组里的数据拷贝到这个数组对象中，然后再把这个数组对象给这个自定义对象，这样就可以使两者互不影响，对于String类型的有一个特点，使克隆时拷贝过去的数据还是一样的，本来是要不一样的，但是String类有一个串池，这个数据在串池中已经存在，所以就会复用继续使用之前的地址值，这些都在堆中进行，在Object中的克隆方法为浅克隆，那想要深克隆怎么办呢，我们可以在想要克隆的类中重写克隆方法，先把克隆对象中的数组获取出来，创建一个新的对象，然后拷贝数组中的数据，再使用super.clone和强转先浅克隆，然后再让里面的数组替换为我们新创建的数组，自己来搞深克隆，但是自己写的克隆会有一些弊端，自己写很麻烦，如果这个数组是二维数组，再循环中拷贝过去，的数据仍然会有拷贝地址的隐患，为了一劳永逸，我们在以后进行对象克隆时会用到一个第三方的工具，不是Java写的是别人写的，要先导入第三方的代码，我们要先创建一个lib的包，这个包用于存储第三方代码，先复制文件再Ctrl加V点击ok，右键点击这个代码点击add as library再点击ok就可以了，比如把对象变成字符串，再把字符串变成对象，就可以让对象实现深克隆

## 备注

在Java中不能用null调用方法，如果这个对象不是我们写的，一旦用null方法调用会出现异常，这时候我们就需要进行非空判断，那我懒得写我就可以用Objects

# Objects

它是一个工具类，提供了一些方法去完成一些功能

有三个返回值为布尔值的成员方法要知道

1. equals，***先做非空判断***，比较两个对象，而且这个是可以直接调用的public静态方法，比较完是不是一个对象，是不是null，最后调用对象的equals方法，这个很奇怪，对象又调用它它又调用对象（好吧是我傻逼了，那个equals对比的是String，也就是使用默认的equals方法）总而言之，这个方法会用我的形参的equals                        
2. isNull
3. nonNull和isNull是反过来的

   

