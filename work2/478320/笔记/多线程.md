# 多线程

# 备注套路

1. 写循环
2. 写同步代码块（可以改成同步方法）
3. 判断共享数据是否到了末尾，先写到了末尾的情况，到了末尾更好写，更简单
4. 判断共享数据是否到了末尾（没有到末尾，执行核心逻辑）

## 线程

线程是操作系统能够进行运算调度的最小单位，它被包含在进程当中，是进程的实际运作单位

进程是程序的基本执行实体，在任务管理器中每一个程序都有一个对应的进程

简单理解，应用软件中相互独立，可以同时运作的功能

想360中就有木马查杀，电脑清理，系统修复，这样三个线程

## 为什么要有多线程

一个人在流水线工作，十分钟流水线来一个快递，那么就有九分钟会被浪费

我们写代码也一样，以前我们写的代码都是单线程代码，cpu每执行一个语法，就要等它执行完才能到下一步，有了多线程我们就可以在执行这个任务的时候同时进行下一步操作

多线程在我们生活中十分常见，原神的加载页面就可能同时有资源加载线程，动画动态化线程，核对版本信息线程等等等

总之多线程可以大大节省我们程序运行的时间

## 并发和并行

并发就是在同一时刻有多个指令在单个CPU上***交替***执行

重点强调交替，比如我要要打游戏一死就要吃东西等复活，这样就是交替执行充分利用时间，就像一个多路开关在电路中不断换线路

并行就是在同一时刻有多个指令在多个CPU上***同时***执行

并行就和并联一样，两个开关连两条电路

如果我有四个线程，如果总线程数小于四个，这个时候就是并行，但是如果总需要线程数越来越多，那就会转换成并发不断交替，随机切换，在我们计算机中并发和并行是可以同时发生的

## 本地方法

在Java中，`native`是一个修饰符，用于标识一个方法是由本地代码（非Java代码）实现的。当一个方法被声明为`native`时，它的实现并不在Java源代码中，而是通过其他编程语言（如C或C++）编写的本地代码来实现。

使用`native`修饰符的方法被称为本地方法（Native Method）。本地方法的实现通常是使用本地编程语言编写的，因此可以直接调用底层操作系统或其他外部库的功能。这在需要与底层系统进行交互或执行一些性能关键的操作时非常有用。

本地方法的声明在Java中只是一个接口，它的实现通常在本地库中。在Java程序中，可以通过Java Native Interface（JNI）来调用本地方法。JNI提供了一组用于在Java代码和本地代码之间进行交互的接口。

需要注意的是，使用`native`修饰符的方法是Java中与平台相关的部分，因为它们依赖于本地代码的实现。因此，使用本地方法需要谨慎，并且需要确保本地代码的正确性和安全性。

以下是一个使用`native`修饰符的示例：
```java
public class NativeExample {
    public native void nativeMethod();

    public static void main(String[] args) {
        NativeExample example = new NativeExample();
        example.nativeMethod(); // 调用本地方法
    }

    static {
        System.loadLibrary("nativeLibrary"); // 加载本地库
    }
}
```

在上述示例中，`nativeMethod`方法被声明为本地方法，并在`main`方法中调用。在静态代码块中使用`System.loadLibrary`方法加载了一个名为`nativeLibrary`的本地库，该库包含了`nativeMethod`方法的实现。

总而言之，`native`修饰符用于标识一个方法是由本地代码实现的，通过Java Native Interface（JNI）可以在Java代码中调用这些本地方法。

## 多线程的实现方式

### 继承Thread类的方式

***可扩展性差，不能再继承其他类***

Thread类表示Java里面的一个线程，如果说我想拥有一条线程的话，那我就需要创建它的对象并开启它，有两种创建线程的方法，第一种是将本类声明为Thread类的子类，该子类应重写Thread类的run方法，run方法中写要执行的代码，接下来就可以分配并启动该子类的实例，也就是说接下来我可以创建子类的对象，再去调用start方法，就可以开启这条线程了，在开启这条线程后它就会自动去找这个子类的run方法，然后执行run方法里面的代码。我们不能直接拿对象调用里面的run方法，如果是这样那只是仅仅调用了一个方法，和我们之前调用一个方法的效果是一模一样的，start才表示开启线程

假设我们两个线程的内容一样或者很多很杂，我分不清这个内容是哪个线程做的，我可以调用这个子类对象的setName方法给它起个名字默认名字是Thread-0和Thread-1，在打印的时候我们可以使用getName加上要打印的内容，这样我们就可以分清哪个线程做了什么，打印后就可以发现我们程序一下执行线程一，一下执行线程二

以下是对start方法的源码分析

start方法是Thread类中的一个方法，用于启动一个线程。下面是start方法的源码解析：

```java
public synchronized void start() {
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    // 将线程状态设置为RUNNABLE
    group.add(this);
    boolean started = false;
    try {
        // 调用start0方法启动线程
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                // 如果启动失败，则从线程组中移除该线程
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing */
        }
    }
}
```

start方法主要做了以下几件事情：

1. 检查线程状态是否为0（NEW）。如果线程状态不为0，则抛出IllegalThreadStateException异常。
2. 将线程添加到线程组中。
3. 调用start0方法启动线程。
4. 如果启动失败，则从线程组中移除该线程。

start0方法是一个本地方法，具体的实现由底层操作系统提供。它负责创建一个新的操作系统线程，并调用线程的run方法来执行线程的任务。

总结起来，start方法的作用是启动一个线程，并在底层创建一个新的操作系统线程来执行线程的任务。

---

不是所有Thread类中的方法都是线程中的方法。Thread类中有一些方法是用于控制线程的行为和状态的，例如start、join、sleep等方法。这些方法可以在其他线程中调用，用于控制目标线程的执行和等待。

另外，Thread类还包含一些静态方法，例如currentThread、yield、interrupt等方法。这些方法可以在任何线程中调用，用于获取当前线程、让出当前线程的执行时间片、中断线程等操作。

除了控制和操作线程的方法，Thread类还包含一些用于管理线程属性和优先级的方法，例如setName、setPriority等方法。这些方法可以在任何线程中调用，用于设置线程的名称、优先级等属性。

总之，Thread类中的方法包括了控制线程、操作线程、管理线程属性和优先级等功能，不仅限于在线程中调用。所以在实际操作的时候还得看看文档来决定

要区分Thread类中的线程内方法和非线程内方法，可以根据方法的功能和用途进行判断。一般来说，线程内方法是用于控制和操作线程的行为和状态的，而非线程内方法则是用于管理线程属性和优先级的。

以下是一些常见的线程内方法和非线程内方法的示例：

线程内方法：
- start(): 启动一个线程。
- join(): 等待线程执行完成。
- sleep(): 使当前线程暂停一段时间。
- interrupt(): 中断线程的执行。
- yield(): 让出当前线程的执行时间片。

非线程内方法：
- setName(String name): 设置线程的名称。
- getName(): 获取线程的名称。
- setPriority(int priority): 设置线程的优先级。
- getPriority(): 获取线程的优先级。
- currentThread(): 获取当前线程的引用。

需要注意的是，并非所有非线程内方法都不能在线程中调用，只是它们的主要功能是用于管理线程属性和优先级。在实际使用中，可以根据方法的用途和功能来判断是否适合在线程中调用。

### 实现Runnable接口的方式

***扩展性强但编程相对复杂，不能直接使用Thread类中的方法***

多线程的第二种实现方式声明实现Runnable接口的类，然后这个类重写里面的run方法就可以了，在测试类里面要先创建一个自己的类，然后在去创建一个线程new Thread(对象名)，然后再用这个新的new的对象去调用start方法（***个人理解：我们创建的这个类没有继承Thread只是实现了Thread继承的接口，仅仅只是可以重写这个run方法用于start，但是start这个方法是在thread类里面的，我们想要启动这个线程这个方法就必不可少，所以Java定义了一个Thread的有参构造，构造器的形参十有八九是这个Runnable接口，果然是这样，我们传入这个形参（Runnable target）后，会修改Thread类中的target变量为我们传入的形参MyThread，而Thread类中的run方法内实际调用的是target.run，这个时候我们运行start方法就会把target，也就是我们传入的MyThread中的run在线程中执行***）为了分清哪个线程是哪个，我们还需要给线程起个名字，我们这次起名字调用的是Thread里面的setName方法，都一样的，上一种方式继承了Thread类才有的这个方法，都一样可以设置，但是这个地方有问题了，我们在MyThread内不能调用getName方法来写在run方法中作为输出的内容，因为这个时候我的MyThread都没继承Thread，（Runnable只有一个run方法getName方法是在Thread中的），自然就没有getName方法，在这里有一种方法解决，在打印之前，我先获取当前线程的对象不就o了吗，理论成立实践想想怎么做，这里会出现一个大问题，我们使用的进程对象是在测试类中的，无法调用这个对象在MyThread中使用，虽然根据顺序结构，run方法在后面执行，但是我们不能在MyThread中调用我们在test中创建的对象，这个时候就出现了一个返回值是Thread类的静态方法currentThread来帮我们获取当前线程，这个方法被native修饰，是一个本地方法，不在源码中展示，现在我们就可以使用这个对象来调用getName方法结果是一样的，但是这样写总归有点麻烦，所以我直接Thread.currentThread().getName,可以节省写代码的时间，这个就叫做链式编程

### 利用Callable接口和Future接口的方式

我们会发现，前面两种方法，不能获取到run方法的结果，因为重写的它没有返回值，那怎么办呢，这时候我们就需要第三种方法

特点，可以获取到多线程的结果书写的时候麻烦一些

创建一个MyThread实现Callable接口<泛型中写run方法返回的结果>，重写里面的call方法（是有返回值的，表示多线程运行的结果，最后在测试类里创建MyCallable的对象，创建Future用于管理多线程的结果（获取，设置等等等），但是这个Future是一个接口，我们要创建它实现类FutureTask的对象<泛型表示run方法返回的结果>使用了有参构造（参数是Callable c）等等去看看它干了什么，最后再创建Thread对象（好家伙出现了，Thread里的有参构造传入了（FutureTask f）这一步很关键，FutureTask可能实现了Runnable接口），并启动，使用创建的FutureTest类的get方法获取这个返回值，最后输出

逻辑原理

创建Future Task的对象时使用了有参构造，使这个对象的callable变量变为传进来的callable,使state变为new，再创建Thread对象时使用了有参构造，传入了FutureTask，使用了里面的run方法。这时候很明显FutureTask里面的run方法至关重要，run方法先是判断state是不是new，然后给这个线程设置为runner（只有在它原本没有名字的情况下才能设置，并返回true）只有这两点同时成立才不会报错，run方法创建了一个与继承了Callable类的MyThread2的call方法返回值类型相同的一个变量result，并使其等于call方法的返回值，同时进行call方法的使用，和一个判断boolean run变量，一旦正常运作，run会被赋值为true，如果在给result赋值时出现了Throwable ex的异常，就会使ran变为false，result变为null，并设置outcome为这个异常（再使用get方法就会得到这个异常），最后如果run是true就会设置这个result为outcome这个可以通过get来获取的数，然后，会重新读取任务的状态。如果状态大于等于`INTERRUPTING`，表示任务可能被取消，会调用`handlePossibleCancellationInterrupt`方法处理任务的取消操作。最后还会清除runner将其设置为null最后和之前一样用Thread的有参构造调用FutrueTask的run方法，再用FutureTask的对象调用get方法获取这个最终的result，所以实际上这个run方法还是没有返回值的，只是它获取了call方法的返回值并设置成了一个outcome参数来被获取

outcome还有一步转换为result方法的返回值，result方法内部还会判断一遍这个目前的状态是否异常来选择正常返回outcome，或者抛出异常，get方法最终返回这个result方法的返回值

## Thread中常见的成员方法

1. String getName返回此线程的名字，空参构造给线程设置了默认名字
2. void setName(string name)设置线程的名字，除了这个方法，Thread的构造方法也是可以给他设置名字的，有一个带String name的构造方法，但是这些构造都是父类的构造，它的子类如果没有使用super关键字获取是不能使用的（构造方法不能继承）
3. static Thread currentThread()获取当前线程的对象，如果我们不创建线程就会获取main线程
4. static void sleep(long time)让线程休息指定的时间，单位为毫秒，哪条线程执行到这个方法，那么哪条线程就会在这里停留对应的时间，当时间到了之后，线程会自动醒来，继续执行下面的其他代码，有异常直接抛出，睡眠可以让程序更加有序
---
5. setPriority(int newPriority)设置线程的优先级

6. final int getPriority()获取线程的优先级

   优先级最小是1，最大是10，默认是5，优先级越大，抢占到cpu的概率越高
---

7. final void setDaemon(boolean on)设置为守护线程，备胎线程，当其他线程结束了守护线程就会陆续结束，女神线程结束了，备胎线程也就没有存在的必要了，就会慢慢消亡，比如我循环了一百次，女神线程结束后，它可能不到一百次就凉了

   应用场景，比如两个人用qq聊天，左边的人给右边的人发了一个文件，聊天和发送软件可以看作两个线程，现在把聊天窗口关闭了，传输文件就没有执行的必要了，这个时候就可以把线程2设置成守护线程，，就是退出这个页面就不下载了烦死了
---
8. public static void yield()出让线程/礼让线程

9. public void join()插入线程/插入线程

线程太随机执行了，不太好，那我能不能让线程的执行尽可能均匀一点呢，yield表示出让当前线程的执行权，表示当女神线程打印完后，它就会出让当前的cpu执行权，下一次女神和备胎就会重新再去抢夺cpu的执行权，这样就可以实现让线程尽量均匀，它只能尽可能均匀一点，不是绝对的，用的很少

因为非常喜欢女神，我想先看看女神可不可以追到再考虑备胎，这时候我就像女神线程先打印，有没有办法呢，这个时候就可以用到join，表示把调用它的线程插入到当前线程之前，当前线程肯定是main，因为是main调用它，这件事情肯定是main做的，当然也可以让其他线程调用它，这样就可以实现有序的输出，这里有一个细节join必须要在start方法后执行才有用，因为线程要启动才有线程，没启动没线程自然无法插入

## 线程的生命周期

创建线程对象的时候是新建状态，调用start方法运行线程后变成就绪状态，开始抢夺cpu的执行权，这个时候是正在抢还没抢到，还没法执行代码，只有执行资格没有执行权，抢到cpu执行权后就会变成运行状态执行代码，一旦它的执行权被其他线程抢走，就又会回到就绪状态，如果当前线程run执行完了就会变成死亡状态变成垃圾，如果线程遇到了sleep方法，线程就会被阻塞，就没有执行资格，也没有执行权，睡眠时间到了的时候就会回到就绪状态

## 线程的安全问题

多线程在提高效率的同时会有一个弊端，不安全

我们在售出100张票的例子中会发现，同一张票会被多个线程多次销售，要解决这个问题，只需要在变量前加上static，表示所有对象共享这个数据，就可以了，改完还有问题，虽然输出了一百次，但是输出会有重复，还会有超出范围的，要解决这个问题就需要用到下面的知识

### 同步代码块

当多个线程操作同一个数据的时候会出现问题

1. 相同的票出现了多次
2. 出现了超出范围的票

假设线程1先走，走到if内部后休息十毫米，失去了执行权，这时候ticket还没有加，二线程开启后又进来了，ticket还没有加，三线程又满足条件又进来了，等最后ticket一起加的时候为时已晚，就会超出范围，现在线程一先进行了ticket++的操作，还没来得及打印，执行权就被线程2抢走了，ticket再++，就会造成两次打印出现同一张票的情况，重复的次数少只是因为几率比较小，如果我能把操作系统的一整块数据锁起来，只要我执行里面的代码，就算休眠，别的人也得在外面等着，是不是就可以了呢？虽然这样做会降低性能，但是这是必要的，起码在处理多个数据时可以让性能提升很多

此时会用到一个关键字synchronized(锁对象){操作共享数据的代码}

在书写的时候有两个小细节，锁默认打开，有一个线程进去了，锁自动关闭，里面的代码全部执行完毕，线程出来锁自动打开

锁对象很任意，任意到什么程度甚至连object都可以，但是这个锁对象一定要是唯一的，要在这个对象里加一个静态关键字

这种处理方式就叫做同步代码块

#### 两个小细节

第一个细节synchronized代码块不能写在循环的外面，一旦写外面，就会窗口一直接把一百张票卖完，那就和顺序结构区别不大了

synchronized后面的锁对象一定要是唯一的，如果不是唯一的会怎么样呢

如果锁不是唯一的，两条线程看的是不同的锁，那锁就没有意义了，所以要加上static，不加在创建对象的时候，就会创建不同的锁地址，一般会在锁上写当前类的字节码文件对象类名.class其实就是那个class对象，这个对象是唯一的，因为在一个文件夹里面只能有一个MyThread.class文件（地址）

### 同步方法

如果我们想把一个线程方法里的所有代码全都锁起来，就没有必要去用同步代码块了，我可以直接把synchronized关键字加到方法上，把它写在修饰符的后面就可以了泛型会在它还后面，同步方法有两个小特点

1. 同步方法是锁住方法里的所有代码
2. 锁对象不能自己指定，是Java已经规定好的，非静态是this当前方法的调用者也就是我们再test里创建的mt对象是唯一的，锁对象也就是唯一的，如果是静态方法，是当前类的字节码文件作为对象

现在我用第二种创建线程的方式来做同一道题，这个时候ticket不需要变为静态了，因为第二种方式继承了Runnable对象的类，这个对象只需要被创建一次就可以被Thread的有参构造多次使用，所以就没有必要再加ticket了，Ctrl+Alt+M快速改代码为方法，再加一个锁就可以了，感觉这里有点坑啊，如果用的是第一种方法那锁对象就不唯一了，要改为静态方法，这样一来就不可以在一个方法中又修改实例变量，又修改静态变量了，Java这么做肯定有它的道理，但是目前不知道为什么，

对于我们之前学习的，StringBuider，StringBuilder的实例用于多个线程是不安全的，如果需要这样的同步，建议使用StringBuffer

在StringBuffer里的每一个方法都有锁，所以它是线程安全的，以后我们该怎么去选择呢，如果我们的代码是单线程的，使用StringBuilder，如果是多线程环境下，就使用右边的StringBuffer

### Lock锁

虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们看不到在哪里加了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock

Lock的实现比synchronized方法的语句可以获得更广泛的锁定操作，Lock提供了获得锁和释放搜索的方法，这样我们就可以手动的上锁，手动的释放锁

1. void lock():获得锁
2. void unlock():释放锁

Lock是一个接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化，直接用空参构造就ok了，我们在前面上锁，在后面释放锁

但是有个小细节，如果我们使用第一种实现方法来锁，那么就要在锁的对象前加上静态关键字，使所有的对象共享同一把锁防止出错

这个时候新的问题又出现了，程序它没停

解释：线程一进循环后，获得了锁，在休眠时间时，线程2执行，到循环处由于关了门，线程2进不去，假设所有都是1线程抢到cpu现在是最后一张票，还是线程一抢到了执行器，走完一趟后打开锁，现在还是线程一抢到了cpu，一又拿到了锁对象，现在ticket=100就会break直接跳出循环的外面，但这个时候锁还没开呢，还是关的，这就导致了一线程拿着锁对象出去，没有还回来，这就导致了二三线程一直停在上面，程序就不会停止，现在怎么办呢，这不是我想要的啊，哪怕循环结束之后我一定要让你执行，你得把锁还给我，外面可以在break前面再添加一个unlock，但是这样很麻烦，比起锁可视化的初衷，还是有些不足，所以我们通常使用最稳妥的finally，不管怎么样它后面的代码一定会被执行，所以我们就可以使用这个特性把unlock放到finally里，把加锁后的所有代码放到try中，这样就可以保证锁一定会被释放

![_-1902245389__08468e0e68073c46de8b1eec2d6aa7c8_1677538590_Screenshot_2023-10-24-23-17-43-45_149003a2d400f6adb210d7e357a3a646_0_xg_0](C:\Users\余思衡\AppData\Roaming\Tencent\QQ\Temp\_-1902245389__08468e0e68073c46de8b1eec2d6aa7c8_1677538590_Screenshot_2023-10-24-23-17-43-45_149003a2d400f6adb210d7e357a3a646_0_xg_0.jpg)

### 死锁

什么是死锁呢，就是在我们的程序之中出现了锁的嵌套，外面一个锁，里面一个锁，就形成了死锁，死锁是一个错误不是一个知识点

比如两个线程，两把锁，A线程执行完毕需要过A，B两把锁，B线程执行完毕要过B，A这两把锁，这个时候就会出现问题

![_1730627709__423dd2544113baf89fc967cf2587625f_1638758016_Screenshot_2023-10-25-10-45-11-57_149003a2d400f6adb210d7e357a3a646_0_xg_0](C:\Users\余思衡\AppData\Roaming\Tencent\QQ\Temp\_1730627709__423dd2544113baf89fc967cf2587625f_1638758016_Screenshot_2023-10-25-10-45-11-57_149003a2d400f6adb210d7e357a3a646_0_xg_0.jpg)

假设A锁上了A门，还没执行到B锁锁上，这个时候B线程把B锁锁上了，那A就下不去，A锁开不了，B也下不去B锁开不开，程序就会无法结束，直接卡死，在以后在写锁的时候千万不要让两个锁嵌套起来

## 生产者和消费者（等待唤醒机制）

生产者消费者模式是一个十分经典的多线程协作模式

等待唤醒机制可以打破随机，让两条线程轮流执行

一条线程我们称为生产者，用于生产数据

另一条线程我们称为消费者，用于消费数据

现在假设生产者是厨师，消费者是吃货，我们还需要有一个第三者桌子，核心逻辑：利用桌子来控制线程的执行，如果桌子上有一碗面条，就是吃货执行他负责吃，如果桌子上没有面条就是厨师执行，负责做面条，理想情况是厨师先抢到cpu执行权，厨师去做面条，再让吃货线程来吃，但是线程的执行具有随机性，所以我们要来解决这个问题，分吃货抢到吃货抢到抢到，理想情况，厨师抢到厨师抢到

第一种消费者等待，如果一开始是吃货先抢到执行权，让他先等着wait，然后就会被厨师抢到，厨师看到没有面条就开始做，做完了，喊吃货去吃，叫做唤醒，notify

第二种生产者等待，一开始厨师抢到执行权，桌子上没有食物，制作食物，把食物放在桌子上，叫醒等待的消费者开吃，这个时候没人在等，没什么关系，没啥影响，这个时候还是厨师抢到执行权，厨师不能再做面条了，桌子上已经有了，厨师只能等着，现在就要判断桌子上是否有事物，有就等待，没有再制作食物，等待后吃货就来了，吃货就会吃掉这碗面条，再唤醒厨师继续去做

![_2022457796__22bceab21fa8bfd7faa7e22958c4abe0_745588957_Screenshot_2023-10-25-11-06-30-53_149003a2d400f6adb210d7e357a3a646_0_xg_0](C:\Users\余思衡\AppData\Roaming\Tencent\QQ\Temp\_2022457796__22bceab21fa8bfd7faa7e22958c4abe0_745588957_Screenshot_2023-10-25-11-06-30-53_149003a2d400f6adb210d7e357a3a646_0_xg_0.jpg)

这个过程中涉及三个方法

void wait() 当前线程等待，直到被其他线程唤醒

void notify()随机唤醒单个线程，不确定的因素比较多

void notifyAll()唤醒所有线程，一般使用下面这一个

### 备注：

以后处理这样的复杂问题一定要先写思路，再做代码实现，这次就是分三类情况，消费消费，生产生产，消费生产

### 控制器代码实现

这个类在上面的例子里代表桌子，它要有一个状态，是否有食物，应该用boolean类型，因为这个变量是共有的，所以是静态变量，来了来了，boolean只有两个值，只能控制两条线程来执行，有点弊端，还是使用int的0和1比较好，以后需求变更，就很难搞，为了考虑到后面的通用性，使用int类型，如果以后我要考虑四条线程，那我只要给它的值一个定义就可以了，吃货不能一直吃吧，定义一个count表示吃货最多只能吃五碗，在线程当中它要用到锁，所以还要添加一个锁对象

### 消费者代码实现

利用套路进行书写，先写一个死循环，用吃了足够多的碗来break，锁上，判断没吃十碗，继续吃，吃了十碗，跳出循环

这里有个细节，不能直接调用wait方法，要用锁对象调用wait方法，为什么是这样的呢，这行代码在底层有一个逻辑，让当前线程和锁绑定，一旦绑定在下面，我们notifyAll的时候就可以进行操作了，我在唤醒的时候不能唤醒操作系统里所有的线程吧，要唤醒哪些呢，其实就是和锁有关系的，我们调用notifyAll方法的时候也是通过锁进行调用的，表示我要唤醒这把锁绑定的所有线程，所以需要使用锁对象去调用wait方法

### 生产者代码实现

第一步循环，第二步同步代码块，第三步判断，第四步还是判断，总体和消费者代码实现差不多，太爱了这个结果！！！实在完美，爱死阿伟了

### 阻塞队列方法实现

阻塞队列就好比连接生产者和消费者之间的管道，以之前的例子为例，厨师做好面条后就可以把面条放在管道当中（看上去可以一次做好多碗），吃货就可以从管道当中获取面条去吃，最重要的是，我们可以在管道当中去规定可以放多少碗面条，如果规定最多只能放一碗，运行结果就会和我们刚刚一样

阻塞队列可以分成两个单词理解，一个是阻塞，一个是队列，先来解释队列

数据在管道中就好像排队一样，先进的先出后进的后出

阻塞，put数据的时候，如果说中间的管道已经放满了厨师就会等着，等着的这个动作就叫做阻塞，take数据时，当吃货从管道当中获取不到数据了也叫阻塞

#### 阻塞队列的继承结构

阻塞队列一共实现了4个接口，Iterable，Collection，Queue，Block Queue，最上面实现了Iterable说明阻塞队列可以使用迭代器遍历，增强for遍历，本身还实现了Collection这个接口，说明阻塞队列本质上就是一个单列队列，Queue表示是队列，BlockingQueue表示阻塞队列，我们要创建他们的对象，要创建他们实现类的对象，第一个ArrayBlockingQueue，LinkedBlockingQueue，他们的区别大概可以猜到，具体区别在下说明

第一个底层是数组实现的，有界，必须去指定队列的长度

LinkedBlockingQueue，底层是链表实现的，无界，没有长度的限制，不需要去指定队列的长度，但是不是真正的无界，这个最大值是int的最大值有二十一个亿那么多

#### 阻塞队列的实现

用阻塞队列来实现等待唤醒机制代码非常的简单，但是有一个小细节要注意，生产者和消费者必须使用同一个阻塞队列才是可以的，阻塞队列有一个泛型，直接new ArrayBlockingQueue就可以了new的对象使用有参构造，形参放入队列的长度

阻塞队列放在cook和foodie都不合适，我们可以把它放在测试类当中，我们有了这个阻塞队列，再通过创建对象的方式把这个队列传递给cook传递给foodie（有参构造来了！）做完了以上的工作后我们就要补全run方法

厨师对象中在队列使用put方法，有异常抛出，锁都不要，分析一下，看看源码，在方法当中它会用lock锁的方式，把代码锁起来，在方法中调用一个锁对象，用一个方法lockInterruptibly获取锁，在下面进行循环判断，判断里面数据的个数和长度是否相等，装满了就等待，没有装满就往里面放数据，并使用finally释放锁，在我们自己的代码中再写锁就锁套锁了，很不建议使用，没面的时候他自己会阻塞不需要我们再操作，take方法也是一样，忘记说了这两个都是实例方法

这个时候发生问题，那我有put，take后我锁不了了啊，再锁就锁套锁了，这个时候打印语句在锁的外面，不过还好没有对数据造成影响只是顺序不太对，但是还是很不爽，也就是说我打印顺序是乱的，但是我的数据不会出现重复越界的情况，甚至可以说不会出错

## 线程的六种状态

之前简单的分析过线程的新建就绪运行死亡阻塞，这五种状态但是还不够完整，除此之外还有几种线程运行的状态需要我们了解，如果说我们使用了wait方法就会进入到等待状态，直到别人唤醒它为止，变成就绪状态，如果遇到了sleep方法会进入计时等待状态，时间到了就会进入就绪状态，但是这里有个小细节，Java的虚拟机里是没有定义运行状态的，这里的运行状态是为了方便理解加上的，为什么Java没有定义呢？

当线程抢夺到cpu执行权的时候，这个时候JVM虚拟机就把线程交给操作系统管理了，虚拟机就不管了，不是它的事，是操作系统的事情了，所以在Java当中，一旦线程抢到cpuJava都把它交给操作系统了，接下来Java都不能对他做什么，都是操作系统的事情了，那干嘛还要定义呢？

所以只有六种状态

## 综合练习

我们使用多线程时，由于集合是引用传递，不需要使用静态变量，在抽奖箱的练习中我们发现，我们每创建一条线程都要创建一个集合来接收这个线程里拿到的数据，那我们有一百条线程怎么办，就不合适，后面判断会写死

我们可以把集合直接删掉，把定义集合的办法写在方法当中，就只要写一个了，每次调用都会创建一个，早不说，害的我还改了服了

现在我要比较两个线程的最大值哪一个更大怎么做呢，首先我们要想，想比较两个线程的最大值肯定要两个线程都走完了才可以比较吧，那我们学习过，获取两个线程的run方法中的对象肯定不行啊，方法中的对象怎么获取，那获取box类的对象的变量呢，我们可不可以让一个变量的结果是比较完两个线程最大值后的最大值呢，好像是可以的，我们使用一个静态变量，判断这个静态变量的值是否小于数组中数据0的最大值，如果是就为它赋值为更大的那一个，现在，我还想知道是那个线程获取的最大值又该怎么办呢，如果我再创建一个变量直接在判断的同时获取现在的线程是不是就可以了，把最后获得的结果在Test方法里输出（在run方法里输出不太合理，因为如果我多次覆盖这个最大值，就会输出多次），理论可行

其实用第三种创建线程的方法获取返回值也可以做到这一点

## 线程栈

每一个线程都有自己的一个栈，但是堆是唯一的，每个线程都有自己的栈就表明我在同一个线程类的run方法中创建一个同名的ArrayList，创建一个新的线程的时候就会有两个不同的ArrayList在两个栈中互不干扰

## 线程池

吃饭买碗的小故事，浩弟要去吃饭，家里没碗了，就要去买一个就可以开始吃饭了，吃完饭浩哥懒的洗就把碗摔了，到了晚上发现家里还是没有碗，只能又买一个碗

每次都要买碗浪费时间

每次都要把碗摔了浪费资源

解决方法只要有一个碗柜就可以了，下一回要用到的时候再拿出来用就可以了

以前写多线程的弊端，用到线程的时候就创建，用完之后就消失，但是这种做法是不对的，会浪费操作系统的资源，所以需要改进，所以我们需要准备一个容器去存放线程，这个容器就是线程池，一开始容器是空的，当我们给线程池提交一个任务的时候，线程池就会自动的去创建一个线程，拿着这个线程去创建任务，执行完了再把线程还回去，下次要用再拿出来，这就是核心原理

特殊情况，如果我在执行第二个任务的时候，线程还在执行第一个任务呢，它还没有还回去，此时线程池就会创建一个新的线程，那这个线程去执行第二个任务，执行完毕就会把线程还回去

线程池是有上限的，而且这个上限可以自己设置，如果我设置了最大线程为3，那剩下的就得等着

这些创建线程啊，给线程啊代码都不要我们写线程池会自动去完成，我们只要提交任务就可以了

所有任务全部执行完毕，关闭线程池，但在我们实际开发中，线程池是不会关闭的，因为服务器是不会关闭的，随时随地都会有新的任务要执行，线程池也就不会关闭

### 线程池代码实现

创建线程池在Java中有一个工具类，Executors，通过这个工具类我们就可以通过调用方法返回不同类型的线程池对象

public static ExecutorService newCachedThreadPool()创建一个没有上限的线程池，但是不是真的没上限最多可以创建21个亿多的线程，绝对够用，电脑会先崩

public static ExecutorService newFixedThreadPool(int nThreads)创建一个有上限的线程

ExecutorService对象方法

shift加f6快捷改类名，CTRL+alt加v快速生成左边，怎么这么多奇奇怪怪的快捷键

1. submit(Runnable task)提交任务，可以提交Runnable的实现类
2. submit(Callable task)提交任务，可以提交Callable的实现类
3. shutdown()销毁线程池

我让每个线程执行任务的时候先睡一秒钟，足够线程一完成任务了，就会发现每一次都是1在做这个任务验证了上面的说法

### 线程池进阶

我们前面学习了两个创建线程池的方法，方便是方便但是不够灵活，比如当我提交的任务比较多，这个任务就会排队等待，比如我想修改队伍的长度就修改不了，那我能不能不用工具类自己创建线程池的对象呢，这样我就可以对我想要的参数进行设置了

跟进newFixedThreadPool后发现，底层实际是创建了一个ThreadPoolExecutor的对象，创建这个对象的时候传递了很多的参数，这是一个怎么样的类呢？

它的构造方法传入的参数非常多，有七个，现在用一个故事来理解

浩浩开了个饭店，一个服务员就服务一个顾客，顾客走了服务员才可以服务别人，浩浩很扣，不知道饭馆能支撑多久，来了顾客才招聘，来几个招聘几个，现在来了三个顾客一直没走，没有空闲的服务员，就会再招聘，饭店不大，最多只能招聘六名，有三个正式员工，三个临时员工，这两种员工，有什么区别呢，临时工有一段时间闲着就会被辞掉，正式员工除非饭店倒闭，否则不能辞退，上面是生意不好的情况，如果生意很好，顾客就会排队，如果排队过长也会产生隐患，顾客心理就会很暴躁，于是老板就指定了个规则，最多只能有十个人排队，其他的顾客只能拒绝服务

核心元素

1. 正式员工数量|核心线程数量

2. 餐厅最大人数 |线程池最大线程数量

3. 临时员工空闲多长时间被辞退（值）|空闲时间（值）

   空闲六十秒就被辞退，这个值就是60

4. 临时员工空闲多长时间被辞退（单位）|空闲时间（单位）

   这个数值就是秒，34是协同运作的

5. 排队的顾客|阻塞队列
6. 从哪里招人|创建线程的方式
7. 排队人数过多拒绝服务|要执行任务过多时的解决方案

我们自己定义的线程池，也会有上面七个对象

临时线程的创建时间是在核心线程都在忙，队伍长度排满时才会创建临时线程，临时线程来处理不在队列内但是待执行的任务（假设我们有十个线程，就是先做123，队伍放456，临时线程做789，第十个销毁，会触发任务的拒绝策略，舍弃不要），任务在执行的时候，不一定先提交的先执行，假设提交任务超过核心线程数量加临时线程数量加队伍长度，就会被销毁

#### 任务拒绝策略

Java种的任务拒绝策略有四种

1. ThreadPoolExecutor.AbortPolicy,默认策略，丢弃任务并抛出异常
---
下面只需要了解就可以了
2. ThreadPoolExecutor.DiscardPolicy，丢弃任务，不抛弃异常，这是不推荐的做法
3. ThreadPoolExecutor.DisCardOldestPolicy，抛弃队列中等待最久的任务，然后把当前任务加入队列中，抛弃第一个队列中的任务，添加最后一个
4. ThreadPoolExecutor.CallerRunsPolicy调用任务的run方法绕过线程池直接执行

#### 自定义线程池代码实现

因为传入的参数非常多，我们分很多行一行一行来写，每个参数就对应上面的起个参数，书写的时候最大线程数量要大于核心线程数量，单位要调用TimeUnit来表示，线程池在哪里获取线程，不能直接用new的Thread，要用Executor的静态方法defaultThreadFactory默认线程工厂，它的底层也是new了一个DefaultThreadFactory，里面也是new了一个Thread，只不过给这个线程做了一系列的设置，任务拒绝策略是ThreadPoolExecutor的静态内部类，如果创建它的对象呢，直接new外部类.内部类，为什么要把任务拒绝策略定义为内部类呢，这个思想之前也说过，只有内部类依赖外部类存在，单独存在没有任何意义，而且内部类的本身又是一个独立的个体，这个时候就要定义为内部类，比如人的心脏，单独存在没有意义，汽车发动机，要依赖汽车才有意义，发动机又是一个独立的个体，现在来理解任务的拒绝策略，单独存在没有意义啊，是专门为线程池服务的，而且任务的拒绝策略又是一个独立的个体，所以就把他定义为线程池的内部类了，下面我们直接提交任务就可以了
