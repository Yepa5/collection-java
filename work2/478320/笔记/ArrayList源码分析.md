# ArrayList底层原理

（底层是数组结构)默认长度是10

数组添加满后会自动扩容1.5倍

上两句话只有前面括号部分是对的，其他的不完整

ArrayList中存在addAll方法可以一次加入一个ArrayList中的全部数据

利用空参构造创建集合时，创建一个默认长度为0的数组叫做elementDate，一个成员变量size用于记录元素个数，在添加第一个元素时，底层会创建一个新的长度为10的数组

这个时候集合的长度确实是1，但是size有两层含义，第一个是元素的个数，还表示下一个元素的存入位置

存满时再存会自动扩容1.5倍，会创建一个新的数组，然后把所有的元素拷贝到新数组当中

如果一次添加多个元素1.5倍还放不选，则新创建数组的长度以实际为准，比如我在存满10个的数组中一次用addAll存入100个，那么这个数组就会有110个数据

Ctrl加N查看源码，Alt加7，查看大纲，或者Ctrl加F12

可以发现，elementDate在ArrayList的空参构造中被赋值了一个长度为0的数组

add方法中还有一个add，这个add判断当前元素的位置，如果数组满了，就调用grow方法进行扩容，grow方法里面还有一个grow，扩容时计算新数组的长度，再调用Arrays里的copyof方法进行复制

第二个add方法有三个参数，参数1是当前要添加的数组，参数2是集合底层数组的名字，参数3是集合的长度，也是当前元素应存入的位置，我们一开始的长度是0，和集合的长度一样，触发grow方法，它会把现有的size+1，再去调用一个有参的grow方法，调用这个有参grow时，它的参数就是1，一给了mincapacity，也就是最少需要多少容量，在这个方法中，先让这个元素的长度等于原来的老容量，如果老容量大于0或者elementDate不是空的数组，就走第一步，现在不满足走else，会比较最小容量和默认10的容量谁大，谁小，比较后取大的一个10，就会创建一个长度为10的数组然后返回这个数组，然后把现在的值e添加到size的位置

如果长度为10的数组已经装满了又改怎么扩容呢，前面和以前一样，不过这次走if里面的方法了，因为老容量大于0了，这次让新容量为调用ArraysSupport的newlength方法的返回值，方法传了三个参数，第一个是老容量，第二个是需要的最小容量减老容量（表示理论上至少我们要新增的容量），第三个是老容量右移一位也就是除以2（也就是默认新增容量的大小），在newLenth方法中，会比较至少要增加的容量和默认要增加的容量哪个大（这个比较就有意思了，可以说明如果一次添加很多个元素的情况下，至少要增加的容量就会大于默认增加的容量，那么就会使集合的扩容值为增加的默认值）***思考，我认为这看似一次添加很多其实还是一个一个添加，因为要触发集合长度等于现在长度的条件，剩下的数一次添加，gpt告诉我是一次添加的，我保持怀疑态度（破案了，看了下源码，触发grow的方式不一样，确实是一次添加直接copy）***，更大的会被留下加上老数组的长度作为新数组的长度，然后进行copyOf方法，创建一个新的数组并进行拷贝，，会根据第二个参数创建新的数组，会把第一个参数中的所有数据全部拷贝到一个新数组中，新数组的长度就是新的长度，然后再回到add，后让size加1

最后的最后，这两张图实在太好，务必要奉上

![](C:\Users\余思衡\Desktop\Markdown学习\图片保存处\QQ图片20231009204614.jpg)

![](C:\Users\余思衡\Desktop\Markdown学习\图片保存处\QQ图片20231009204630.jpg)