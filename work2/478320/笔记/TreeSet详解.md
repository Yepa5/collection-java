# TreeSet

不重复，无索引，可排序

按照元素的默认规则又小到大进行排序

TreeSet底层是红黑树

forEach底层是增强for

如果存的是自定义类型该怎么排序呢

## 默认排序

对于数值类型默认按照从小到大进行排序的

对于字符，字符串类型，按照字符在AScll码表中的数字升序进行排序，每个字符对应着相应的数字，如果字符串里的字符比较多，会从首字母开始比较，如果aa和aab比较，aab会比较大

在TreeSet中我们直接添加自定义对象会报错，因为我们没有给它添加比较规则，所以我们需要给他指定比较规则，有两种方式

1. 自然排序，JavaBean类实现Comparable接口，重写里面的抽象方法指定比较规则，这个接口有泛型，我们有两种实现方式，把学生类的年龄减去形参o的年龄作为返回值就可以，根据正负来判断顺序，如果相同就认为重复了会被抛弃，排序规则中this表示当前要添加的元素，o表示已经在红黑树存在的元素，让这两个数相减，如果是负数，存左边，如果是正数存右边（开始红黑树了），正是因为红黑树，会使我们的输出有序，小的在左边大的在右边

   ![](C:\Users\余思衡\Desktop\Markdown学习\图片保存处\Screenshot_2023-10-11-20-39-33-04_149003a2d400f6a.jpg)

   但是我要在年龄相同时比较姓名怎么办呢，那我要比较姓名总不能要减吧，这个时候就不能满足我们的需求了

2. 比较器排序，我们可以在创建TreeSet对象的时候传递比较器Comparator指定规则。***使用原则，默认使用第一种，我们使用第一种不能满足时用第二种***，比如我要改变String的排序方式，我总不能重写源码吧这时候就需要比较器

   默认情况下我们使用的TreeSet是空参构造，但如果我们在TreeSet的构造（默认返回值规则相同）时使用形参为Comparator的构造方法（就是在new这个对象时在后面写形参的地方写上new Comparator匿名内部类）o1表示当前要添加的元素,o2表示红黑树中已经存在的元素，我们可以运用三元运算符来在这个匿名内部类中通过改变返回值改变他的对比方法

   我们还可以写成lambda表达式的形式，因为Comparator是函数式接口

如果方式一和方式二同时存在，听谁的呢

答案以方式2为准，实例来看，就String类型，它内部已经重写了Comparable接口，这时我们使用比较器后，我们仍然可以改变比较规则，个人认为是顺序问题方式1会被覆盖