# List集合

首先说明，List集合可以使用所有Collection内的所有遍历方式和方法

## 特有方法

因为List有索引所以多了很多索引操作的方法

void add(int index,E element)在此集合中的指定位置插入指定的元素，这个位置上的元素就被顶到后面了

E remove(int index)删除指定索引处的元素

***remove方法有个非常恶心的小细节，如果我们的集合是包装类的数字，由于分不清我们到底是想删具体的元素还是指定索引的元素，那么我们删除时会默认删除指定索引的元素***

***为什么会这样呢，在我们调用方法的时候，我们给的参数两个方法都能接收不知道调哪一个时，如果方法出现了重载现象，那么它会优先调用形参和实参一致的那个方法，直接删除数字需要自动包装这个数字类，然后再调用remove，而根据索引删除的不需要做任何操作就可以直接调用，所以默认先调用第二个remove***

***那我就是要删掉具体的元素我该怎么办呢，很简单，我可以提前把一通过包装类包装给一个i，我们使用这个integer类型的i，就会优先调用直接删除的remove方法了***

```java
Integer i=Integer.valueOf(1)
```

E set(int index,E element)修改指定索引处的元素

E get(int index)获取指定索引的元素

List也是接口不能直接创建它的对象，要用它实现类的对象来帮助创建

## List集合的遍历方式

除了Collection中的遍历方式List还有它自己独特的遍历方式

列表迭代器

列表迭代器再Java中有一个名字ListIterator是接口，这个接口继承了迭代器接口，是迭代器接口的子接口

里面有add添加指定元素，而且是利用迭代器里的方法进行添加

还有迭代器中的next，hasNext,remove都有

还有两个了解一下，hasprevious和previous，和next相反，而且是先移动指针再读数据，这是从后往前移动指针，它们有局限性，开局直接用会报错，要先往后才能往前，不能直接反向读取数组

主要是它有add，很不错

使用迭代器的时候一定要记得只能由一个迭代器next方法，要使用他的值，一定要用一个数先获得他的值，要不然会造成迭代器指针越界

***但是使用add元素增加的元素不能被遍历，在使用ListIterator的add方法向列表中添加元素时，新添加的元素会被插入到当前迭代器的位置之前。先得到目标元素，然后移动指针，接着再在目标元素后添加元素，可是这个时候指针已经到添加元素的后面了，我们只要用previous返回后再遍历一次，就可以找到我们新添加的元素***（remove）也一样

普通for循环遍历

这个太简单就不说了，遍历后想操作索引就用这种遍历方式
