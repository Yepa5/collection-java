# BigInteger

long都不够用时，只要不是小数它都可以表示，有上限，上限太大了，可以看作是无限的

我们要先获取它的对象，由于它有构造方法的重载，我们有下面几种方法来获取它

1. BigInteger（int num（随机范围[0~2的num次方减1]）,Random rnd）获取随机大整数
2. BigInteger（String val）获取指定大整数，字符串里必须是整数也只能是整数，否则会报错NumberFormatException，数字格式话异常***常用***
3. BigInteger（String val，int index（进制））获取指定进制的大整数，但是二进制只有0和1，我们不能写23456之类的数，否则会报错***常用***

还有一个静态方法valueof（long val）静态方法获取它的对象，内部有优化，能表示的范围比较小，如果超出long的范围就不性了，在内部对常用的数字-16~16进行了优化，提前把-16~16先创建好BigInteger的对象，如果多次获取不会重新创建新的，地址值都一样

对象一旦创建，内部记录的值不能发生改变，我们使用add方法将两个数相加时，不会改变BigInteger对象中的值，而是产生了一个新的Big Integer对象来储存这个3

如果BigInteger表示的数字没有超出long的范围，可以用静态方法来获取

如果超出long范围可以使用构造方法来获取

只要进行计算都会产生一个新的BigInteger对象

## 常见方法（实例方法）

1. 加法add
2. subtract减法
3. multiply乘法
4. divide除法，获取商，返回值只有一个
5. divideAndRemainder 获取商和余数，由于结果有两个返回的是数组，0索引是商，一索引是余数
---
7. equals重写过了，比较的是属性值    {之后是比BigDecimal多的}
8. pow次幂
9. max/min返回较大值较小值，他是一个对象，不能直接用大于小于操作，所有操作都要用方法来完成
10. intValue可以变成int类型的整数，但是如果数据超出了范围就会报错

## 底层存储原理

BigInteger有两个成员变量

一个signum记录的是符号，如果是-1是负数，0，就是0，1就是正数

还有一个mag数组，存储了BigInteger里的数据，因为这个数太大了，BigInteger就会对他进行拆分，拆成很多的小段，单独放到数组当中，先把这个数字转换为二进制（正负又前一位来定0正1负），每32位分为一组，各自转换为他们的补码再转换为，十进制

它的储存上限，有，数组有最大长度，是int的最大值，有二十多个亿的三十二位，42亿的21亿次方

扛不住这么大的数字，所以几乎是无限的

# BigDecimal

如果直接使用浮点数相加，比较，由于十位的小数转换为二进制时，小数位会非常多，但是float和double占用的字节位是有限的，超出的部分就会舍弃，大多数情况问题不大，但是在特殊场景问题就很大了，比如存钱，就需要精确运算，在飞机火箭精密零件都需要运用小数的精确运算，这时候就是BigDecimal登场了

## 常用获取方法

爹是number，爷是Object，它和BigInteger一样，是不可变的，精度是任意的，构造方法非常多，接下来讲解几个重要的构造

1. BigDecimal（double val）将小数变成BigDecimal，此构造方法的结果会有一定的不可预知性，用这个方法创造的BIgDecimal还有可能是不精确的，不建议使用
2. BigDecimal（String）不会遇到前面构造方法的不可预知问题，建议使用
3. 这个类中也有一个静态方法valueOf获取对象,如果传递整数，会以一位小数的形式进行计算，其实也是在底层把小数变成字符串再new出来，精确，不过有范围

2和3还是有一些细节的，如果要表示的数字不大，没有超出double的取值范围建议使用静态方法，valueof在底层也做了一些事情，先将这个val传递给这个字符串，long类型的valueof在0到10之间的整数，方法会返回已经创建好的对象，不会重新创建，节约内存

但我存10.0和10就不是同一个对象了

## 常见方法

和BigInteger类似

加减乘除，但是这里除法就没有余数的那个了

这里的除法有一个重载，如果在原有的除法后面加上，下一个就是精确几位再加一个，下一个就是舍入模式（）进一去尾还是四舍五入，因为除法如果除不尽，会出现问题，必须使用第二种方法来做，以前的方法会调用BigDecimal.ROUND_HALF_UP，但是会发现它上面是有斜线的，代表已经过时了，新版本中使用RoundingMode来点

RoundingMode是一个枚举里面有很多枚举方法

1. UP远离0
2. Down向0
3. CEILING向正无限
4. FLOOR向负无限
5. HALF_UP四舍五入，向最接方向的舍入模式，距离相等向上舍入
6. HALF_DOWN,五舍六入

## 存储方法

0.226小数位有55位，如果换成了几百位几千位效率就非常低，所以在JAVA中换了另外的一种方式获取，字符串输入后，会得到每一个字符，再把这些字符放入Ascii表当中对应的数字进行存储，底层也是一个数组，存的是每一个字符在Ascii表中对应的数字，123.226存七位，-1.5存四位，正号是不存的，这个数据也是有上限的，这个小数上限也贼大和上面一样，可以认为是无限大的