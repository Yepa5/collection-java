# 数据结构

计算机存储数据组织数据的方式

不同场景下要使用不同的数据结构

List下的三个不同的类在底层就有不同的数据结构

## 八种基本数据结构

1. 栈
2. 队列
3. 数组
4. 链表
5. 二叉树
6. 二叉查找树
7. 平衡二叉树
8. 红黑树

## 栈

后进先出，先进后出

一端开口为栈顶，另一端为栈底

数据进入栈模型的过程称为压/进栈

和一个子弹弹夹一样

数据离开栈模型的过程称为弹/出栈

Java内存结构中有一块区域叫做栈内存，方法被调用时就会进栈，先调用的方法在下面，执行完了出去

## 队列

两端开口，一个前端一个后端

队列先进先出，后进后出

进队列称为入队列，从后端进去

从前端离开队列过程称为出队列

和排队买票一样

## 数组

查询数据时先通过地址值找到整个数组再通过索引来找到具体的数据，查询任意数据耗时相等，查询速度比较快，元素在内存中是连续储存的，删除数据时要将原始的数据删除还要把后面每个数前移比较麻烦，效率很低，添加也一样，是一种查询快增删慢的模型，那么有没有和数组刚好相反的一种模型存在呢？

## 链表

每一个元素称为结点，每一个节点都是一个独立的对象，每个对象有一个独立的地址，表示节点在内存中的位置，节点储存具体的数据和下一个节点的地址值，第一个节点叫头节点，链表中的每一个结点都是一个独立的对象，在内存中是不连续的，每个结点包含数据值和下个结点的地址值，链表查询会很慢无论哪个数据都要从头开始找，链表增删相对快，我要加入一个新的节点，我只要写上我这个结点的下一个地址，和改变上一位结点的下一位地址，就可以直接在具体的位置实现增加减少了

除了简单的单项节点，还有双向结点，在第一位还会加上前面的地址值，这样的链表不仅可以从前往后查，还可以从后往前查，可以提高查询效率

元素游离，查询首位操作极快

