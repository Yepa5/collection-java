# HashSet

Set系类的集合不需要我们学习新的方法，使用Collection接口里的方法就可以了

HashSet，无序，不重复，无索引

我们添加顺序和取出顺序不同

## HashSet底层原理

底层采取哈希表存储数据，哈希表是一种对于增删改查数据性能都很好的结构

由数组，链表和红黑树组成

哈希表中有一个哈希值（对象的整数表达形式）

要根据公式int index =(数组长度-1)&哈希值;来判断存储数据的顺序，这个hashCode方法在Object类中所有对象都可以使用，默认使用地址值进行计算，但是根据地址计算得到的结果，每什么用，一般情况下会重写hashCode方法，可以通过属性值进行计算哈希值，就可以达到不同对象只要属性相同就认为是同一个对象的效果

在小部分情况下不同的属性值或者不同的地址值计算出来的哈希值是一样的，这种情况称为哈希碰撞，是有可能发生的，不过概率不高

第一步创建一个默认长度为16，默认加载因子为0.75的数组，数组名为table

根据元素的哈希值和数组的长度进行计算出应存入的位置，进行位运算符运算

判断当前位置是否为null，如果是null直接存入

如果位置不是null，会调用equals方法比较属性值，属性值一样，就不存，属性值不一样添加新的元素形成链表，JDK8以前新元素存入数组，老元素在新元素下面，JDK8以后，新元素直接挂在老元素下面

比较存不存不仅仅只看数组中的元素，还需要与链表中的元素进行比较

当我们不断的添加元素，加载因子是HashSet的扩容时机，当数组里面存了16*0.75=12个元素时，数组就会扩容成原先的两倍，当链表长度大于8，且数组长度>=16时，链表就会自动转换为红黑树，从而提高查找效率，如果集合中的是自定义对象一定要重写hashCode和equals方法，如果没有重写，在底层都会通过地址值进行比较，这个对我们意义不是很大

### HashSet的三个问题

1.***为什么存和取的顺序不一样？***

他是从数组的零索引开始一条链表一条链表的遍历，造成存取顺序不同

2.***HashSet为什么没有索引***

因为HashSet不够纯粹，底层太复杂了，不好规定到底哪个是0索引哪个是1索引

3.***HashSet是利用什么机制保证数据去重的***

HashCode和equals方法

### 小练习

![](C:\Users\余思衡\Desktop\Markdown学习\图片保存处\屏幕截图 2023-10-11 193317.png)

如果在使用String和Integer类时不用重写，因为Java已经重写好了

## LinkedHashSet

我们不需要学习新的方法

***底层原理***

有序，不重复，无索引

它会保证数据的存储和取出的顺序一致，数据结构底层仍然是哈希表，只是每个元素又额外多了一个双链表的机制记录存储顺序，它会在底层通过双链表把每一个元素联系起来，就使表有序

以后如果需要数据去重我们使用哪个呢？

默认使用HashSet，除非要求要去重又要有序，才用LinkedHashSet，因为LinkedHashSet效率较低



