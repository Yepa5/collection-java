# 封装进阶

人画圆是属于圆的方法为什么呢

## 对象代表什么，就得封装对应的数据，并且提供数据对应的行为（属性方法的封装）

画园要根据什么来画，肯定要有圆的半径，那么圆的半径这个数据对应的行为是不是就可以是画圆呢，所以画圆这个方法要定义在圆中，圆是自己画的，表示它将来可能出现的行为和状态，人要调用画圆的方法，来执行这个行为落实行动

对于人关门来说，门将来的行为和状态是被关起来，那么这个方法就应该在门中，人只是调用了这个方法，改变门的状态，用封装的思想来理解就是门代表了门这个事物的所有属性和行为，以及它自己将来可能出现的行为和状态，封装了门是否关闭的数据，并且提供开门和关门的可操作的行为

再举一个例子，张三砍了李四，李四是张三砍凉的（这里不是张三砍死的，这两者在这句话中没有因果关系，我们固定的思维会把因果关系不由自主的代入到情景中，但这对于计算机这样机械化的思维是明显致命的）还是李四自己凉的，很明显，李四是自己凉的，张三只是做了一个砍的行为，调用了李四凉的方法，正常点说就是李四将来的行为是凉，是李四自己凉的，只是张三的行为造成他的凉，张三落实了这一行为，但是生死属性的改变，是在李四中改变的，是李四自己的属性发生了变化，不是张三的数据产生了改变，用封装对象的思想就是，李四类里封装了李四是生还是死的数据，并提供使李四生或死的方法

这里如果再加一个斧头类，那么就是张三用斧头砍了李四，那么斧头类的设计我想首先要在斧头类中设计他将来可能出现的行为和状态，斧头类自身状态改变可以忽略不记，那也就是说，斧头类没有封装对应的数据，他也就不需要提供数据对应的行为，斧头类自身应该有一个void（实例方法，便于选择用哪吧斧头）方法命名为砍（这个砍是斧头将来可能出现的行为）这个砍（没有形参）调用了李四的死的实例方法，一个对象也是对象要用实例方法，只有一个对象时，可以只设计一个获取方法，私有化构造方法，可以用final来修饰的一个变量来接收这个唯一的对象（不能有很多个李四），张三作为最终类，暂且不顾他自己的状态，他将调用斧头砍李四的实例方法。

---

***单例模式是一种设计模式，它的主要目的是确保一个类只有一个实例，并提供一个全局访问点来访问该实例。单例模式有以下几个好处：***

***1. 保证唯一实例：单例模式可以确保一个类只有一个实例存在。这对于那些需要共享资源或数据的场景非常有用，例如数据库连接、线程池等。通过单例模式，可以避免多个实例的创建和资源的浪费。***

***2. 全局访问点：单例模式提供了一个全局访问点，使得其他类可以方便地访问该实例。这样可以简化代码的调用方式，提高代码的可读性和可维护性。***

***3. 延迟实例化：单例模式可以延迟实例化，即在第一次使用时才创建实例。这样可以提高程序的性能，避免不必要的资源消耗。***

***4. 控制实例化过程：单例模式可以通过私有构造函数来控制实例化过程，防止其他类直接创建实例。这样可以更好地封装和保护类的实现细节。***

***5. 线程安全性：单例模式可以确保在多线程环境下只有一个实例存在，避免了多线程并发访问时可能出现的竞态条件和数据不一致的问题。***

***总而言之，单例模式可以提供一种简洁、高效、安全的方式来管理和访问类的实例，使得代码更加可控、可靠和可扩展。然而，单例模式也有一些缺点，如可能引入全局状态、难以测试等，因此在使用时需要慎重考虑。***

在上面的例子中，单例模式除了上述的内容外真的还给我提供了许多便利，我不需要考虑我在调用砍方法时获取的李四对象是不是和我要的对象是同一个，省去了创建对象和在砍方法中添加李四对象形参的麻烦

## 封装的好处（封装我的数据）

把数据用一个类型来定义就是封装过程，并使用这个类型中的方法

可以降低我们的学习成本

告诉我们如何正确设计对象的属性和方法

## 私有化

我们在为属性赋值时，比如我们要赋值年龄，但是别的人一不小心把年龄赋值成了负数，代码不会报错，但是和实际情况不符合，会出问题，为了防止这一现象发生，就要用到关键字private，这时候给age赋值负数代码就会报错，这样就解决了数据安全的问题，但是同时又出现了一个问题，我给age赋值了正确的值，代码还是会报错，这不是我我们想要的，我们想要的是正确的数据可以正常赋值，不正确的数据是不能正常赋值的，如果不用私有化对每一个对象都进行判断，是不可行的，有两个理由

1. 人数太多时，每次赋值都要一次判断，实在太复杂

2. 对象代表什么，就得封装对应的数据，并提供数据的行为，那么对属性进行校验的方法也必须写在人这个类中，这时候我们使用get和set方法来在内部给数据进行判断，所有的属性我们还是要加上私有关键字，与此同时，每个属性我们都要加上public的get和set方法，我们在set方法中进行if判断，如果我们赋值正确，就为其赋值，如果我们赋值错误就输出非法数据，这样我们代码中就获取了一个过滤通道

   ***现在可以解释为什么几乎所有的属性都需要私有化了，代码要重新修改，真的裂***

## 多态优势

1. 右边的对象可以实现解耦合，便于扩展和维护

​	Person p=new Student()

​	p.work

​	那我这时候使用的是Student中的work方法，当我下次想要使用teacher的work方法时就会很方便，只要改变一下new的对象就可	以了

2. 定义方法时使用父类型作为参数可以接收所有的子类对象，体现多态的扩展性和便利性，比如我要输入猫或狗，在形参我只要输入Animal对象那么猫和狗都可以使用这个方法

## 多态弊端

传参数容易，用参数独特方法难，我在我的宠物店中大多数方法只需要传入父类共有的属性和方法就可以了，我不可以在方法里调用狗的方法，和狗特有的属性，父类型不能调用子类的特有功能，没被重写的方法就是子类的特有方法，比如狗看家，猫抓老鼠，要想解决这个方法就要把调用者a强制转换成子类类型，这个时候就可以使用子类特有的方法了，但是这个时候不能乱转，比如我们一开始Animal使用的是狗，我们不能把他转换成猫，这两者没有关系，会报错类型转换异常，我们在转换时也许需要使用if语句来判断，有时候我们也不知道我们传入的是什么，用if，elseif来判断，如果是狗转换为狗，如果是猫转换成猫，这就又让我想起了InstanceOf，果然可以用来用在这里，这样我们就可以调用他的特有方法了，如果什么都不是就会输出无法转换，这样虽然可以，但是每次都要判断代码比较复杂，所以Java在JDK14的时候出现了一个新特性，可以把判断和强转写在一行，我们只要写a instanceOf Dog d（这个d是变量名，我们就可以省的写强转那一步了）

## 接口补充

比如我要完成一个搬家方法，那我的形参写什么呢，有那么多东西都可以做到，我写Car吧，那搬家公司不是又要重载一个方法了，这非常的麻烦，所以我们在形参写上他们共同实现的搬家接口就可以完成了，接口只是一种规则是一种行为的抽象，而抽象类更多用在父类当中，是表示动物这一类事物，在表示共性方法的时候，方法体不一样了，就写成抽象方法，而接口更侧重表示为一类行为，他和抽象类功能不同，但是又相似，他们可以使多态实现

JDK7以前：接口中只能定义抽象方法

JDK8新特性：接口中可以定义有方法体的方法

JDK9的新特性：接口中可以定义私有方法
