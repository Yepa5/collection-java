# 泛型

## 泛型基础

使程序员可以定义安全的数据类型，比如在ArrayList类中如果我们不规定对应的泛型，那么很可以程序会出错从而影响到程序安全性

语法     类名<类型参数1，类型参数2>{}

这个类型可以起任意一个名字但是不能是已经有的类名，通常用大写字母（如T）表示，之后就可以直接用泛型创建成员变量T attribute；

也可以放在方法的返回值中

要注意泛型只支持引用数据类型，要输入数字就要对其进行包装，如果数据符合条件就可以存，如果不使用泛型定义，我们add的列表就会是Object爱输什么输什么，甚至可以是自定义的类型

多态的弊端是不能访问子类的特有功能，这个时候我们obj类型的对象，无法实现它本身因有的功能，因为它的类型是父类，那子类本身的方法它就不能调用了，如果不使用泛型来约束它，它就会存在上面所说的致命缺陷，如果使用强制转换，把object转换成特定的子类类型，虽然可以用，但如果在循环一个集合时我们输入了integer形式的object又输入了String形式的object，我们强转这两个object类为String，输出时就会报错，因为integer类无法转换为String类，从上节instanceof可以明白，他们之间没有关系不能转换，这个时候我们就不知道到底强转到什么类型

结论，如果我们没有给集合指定类型，那么就会全部变成object类，造成无法使用我们想要的类型里的方法，强转还行不通，所以Java推出了泛型，可以在添加数据时就进行统一，非常的方便

拓展，Java中的泛型是伪泛型，只在编译时期有效，可以看成一扇门，他筛选了了String形式的变量，实际还是Object类型，但是在我们调用这些数据时，这扇门会做一件事情，他会把object类型强转成String类型，在代码中体现就是编写Java文件中的泛型在编译成class文件时，泛型会消失，这个过程被称做泛型的擦除

为什么不能写基本数据类型呢，因为刚刚说过，Java泛型是伪泛型，在进门后是要重新变成object类型的，但是基本数据类型又不能转换成object类型，所以泛型中不能写基本数据类型

传递数据时可以传递泛型类型和泛型的子类类型，虽然很少这么干

## 泛型进阶

泛型还可以写在方法上面（泛型方法），也可以写在接口（泛型接口）上面

### 泛型类

当写一个类中，某个变量的数据类型不确定，就可以自定义带有泛型的类ArrayList<E>，只有在创建这个类的对象的时候E就能确定它的类型，这里涉及到了面向对象的方法要注意难理解的地方，这个E可以理解成一个变量，不确定，如果不写就会导致变成object，***备注***一旦定义了泛型，那就必须要传一个类型过去

当我们自定义一个ArrayList泛型时，它本质是一个object数组（这也就是为什么ArrayList内部是object的原因，每个被泛型限制的数据都会被自动转为object），当我们要get其中一个数据时我们的返回值是E（这是为什么我们最后会得到E类型的原因），可是E的级别是比object低的所以我们要进行强转，这也就是出来门时，object类型会被转化成E类型的操作，了解源码后可以帮我们更清楚的明白这个整体

### 泛型方法

我们当然可以在定义泛型类时，可以在方法中直接使用这个不确定的类型，但是如果一个类中只有一个方法需要这个不确定的类型，那么就没必要再在类中定义了，可以使用泛型方法，泛型在修饰符后，使用泛型后，在方法的形参和方法的里面都可以使用这个泛型了***思考***：一个类中需要多个泛型时，也可以使用泛型方法来解决问题

***当泛型方法和某个形参中的泛型一致时，我们在调用时只需要写其中的一个泛型定义就可以了，没必要两个都写***

### 泛型接口

只要在接口名后加<>

两种使用方法

1. 实现类给出具体类型
2. 实现类延续泛型，创建对象再确定（这种情况有一个坑，就是泛型接口是E的情况下，在实现方法种这个E是一个新的E，电脑不知道这个E是哪里来的，所以我们要先给实现类定义一个泛型E才能给接口定义这个E是什么）

第一种情况在实现类上直接给出***接口***具体类型（不用写实现类泛型了），我们使用实现类时，就不用再写泛型了，会自动变成E，给非该类型就会直接报错

第二种情况实现类的泛型可以再写E（要记得不能不写，不写会变成object）然后在创建这个实现类对象时就一定要给这个泛型具体的定义了，一定要记得，这个真的巨坑，忘记写直接变成object，真的贼坑，注意三个地方，第一个泛型接口一旦定义，再次使用这个接口也一定要定义泛型，知道上面类型写该类型，不知道就写E，第二个实现这个接口的泛型实现类也要定义它的泛型，是E还是什么，如果后面使用了泛型方法是Object可不写，第三个，我们使用实现类里的方法时也一定要定义这个泛型，三连坑要注意，***当然如果在使用第一种实现方法就不用考虑第三连坑了，会自动变成那个类型***

***泛型一旦定义自动继承性***（这话肯定是自己瞎编的，自个看得懂就欧克）



## 泛型的继承

泛型本身不具有继承性，但是数据具备继承性

这句话意思就是说我定义了一个泛型Ye，那么我可以在集合里添加继承的数据，但是Ye继承的类型不能适用泛型定义的方法

## 泛型通配符 ？

他可以表示所有不确定的类型，但是可以进行类型的限定,有两种方式

1. ？extends E:  表示可以传递E或者E所有的子类类型
2. ? super E:  表示可以传递E或者E所有的父类类型

用？和直接用E其实差不多，不过？属于本来就有的，不需要再在类名后再定义一个泛型



